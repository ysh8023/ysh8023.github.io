---
title: NO.06 Java基础学习&心得体会
date: 2022-04-11 19:42:53 +0800
categories: [Java学习]
tags: [Java学习历程记录]
pin: true
author: 杨圣僧

toc: true
comments: true
typora-root-url: ../../ysh8023.github.io
math: false
mermaid: true



typora-copy-images-to: ..\assets\blog_res\${filename}-img
---





# NO.06 Java基础学习&心得体会



## **一、进制**

### **1.进制介绍**

**进制**：指进位制，是人们规定的一种进位方式

表示某一位置上的数，运算时是逢X进一位。

十进制是逢十进一，二进制就是逢二进一，八进制是逢八进一…

**常见进制**：二进制，八进制，十进制，十六进制

**十进制**

运算规则：逢十进一，借一当十。

**二进制**

**介绍**：二进制数据是用0和1两个数码来表示。例如：0101000

进位规则是“逢二进一”，借位规则是“借一当二”。

**八进制和十六进制**

⚫ **八进制介绍**：采用0，1，2，3，4，5，6，7八个数字，逢八进1 

⚫ **十六进制介绍**：用数字0到9和字母A到F（或a-f）表示，其中:A-F表示10~15，这些称作十六进制。 

【0】【1】【2】【3】【4】【5】【6】【7】【8】【9】【a】【b】【c】【d】【e】【f】

**不同进制的书写格式**

⚫ 十进制：Java中，数值默认都是10进制，不需要加任何修饰。 

⚫ 二进制：数值前面以0b开头，b大小写都可以。

⚫ 八进制：数值前面以0开头。

⚫ 十六进制：数值前面以0x开头，x大小写都可以。

注意：以上内容是jdk7版本之后才被支持。

### **2.进制转换**

#### **Ⅰ、 二进制到十进制的转换**

⚫ 公式：系数 * 基数的权次幂 相加

◼ 系数：每一【位】上的数

◼ 基数：几进制，就是几

◼ 权：从数值的右侧，以0开始，逐个+1增加

![image-20220703234535090](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220703234535090.png)

#### **Ⅱ、 十六进制到十进制的转换**

⚫ 公式：系数 * 基数的权次幂 相加

◼ 系数：每一【位】上的数

◼ 基数：几进制，就是几

◼ 权：从数值的右侧，以0开始，逐个+1增加

![image-20220703234552931](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220703234552931.png)

🟡🟡 总结：任意进制到十进制的转换

⚫ 公式：系数 * 基数的权次幂 相加

◼ 系数：每一【位】上的数

◼ 基数：几进制，就是几

◼ 权：从数值的右侧，以0开始，逐个+1增加

#### **Ⅲ、十进制到二进制的转换**

⚫ 公式：除基取余

使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

需求：将十进制数字11，转换为2进制。

实现方式：源数据为11，使用11不断的除以**基数**，也就是2，直到商为0。 

![image-20220703234727532](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220703234727532.png)

#### **Ⅳ、十进制到十六进制的转换**

公式：除基取余

使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

需求：将十进制数字60，转换为16进制。

实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。

![image-20220703234808939](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220703234808939.png)

 

🟡🟡结论：十进制到任意进制的转换

⚫ 公式：除基取余

使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

#### **快速进制转换法**

⚫ 8421码：

8421码又称BCD码，是BCD代码中最常用的一种

BCD： (Binary-Coded Decimal) 二进制码十进制数

在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来

得到的结果就是它所代表的十进制数。

**二进制快速转十进制**

![image-20220704085956793](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220704085956793.png)

**二进制快速转八进制**

八进制：将三个二进制位看为一组，再进行转换

原因：八进制逢八进一，三个二进制位最多可以表示111，也就是数值7，如果出现第四位，就超范围了

需求：将60的二进制0b111100转换为八进制

![image-20220704092614341](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220704092614341.png)

**二进制快速转十六进制**

十六进制：将四个二进制位看为一组，再进行转换

原因：十六进制逢十六进一，四个二进制位最多可以表示1111，也就是数值15，如果出现第五位，就超范围了

需求：将60的二进制0b111100转换为十六进制

![image-20220704092658545](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220704092658545.png)

### **3.原码反码补码**

⚫ 原码反码补码介绍

注意：计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的。

⚫ 原码（可直观看出数据大小）

就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。

通过一个字节表示+7和-7，代码：byte b1 = 7; byte b2 = -7;

一个字节等于8个比特位，也就是8个二进制位

0(符号位)             0000111

1(符号位)             0000111

⚫ 反码

正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。

⚫ 补码（数据以该状态进行运算）

正数的补码与其原码相同；负数的补码是在其反码的末位加1。

⚫ 原码反码补码介绍

正数的原反补都是相同的

负数的【反码】，是根据【原码】取反(0变1，1变0)得到的 **(符号位不变)**

负数的【补码】，是根据【反码】的末尾+1，得到的

⚫ 求-7的补码

原码 ：1(符号位) 		0000111	--->		符号位不变，0变1，1变0

反码 ：1(符号位) 		1111000	--->		反码的末尾+1，求补码

​												+1

补码 ：1(符号位) 		1111001

⚫ 原码反码补码介绍

**byte b = (byte) 130;**

**System.out.println(b);** 

① 整数130 ：默认为int，int占用4个字节，也就是4组8个二进制位

**00000000 00000000 00000000 10000010**

② 强转到byte：4个字节，强制转换为1个字节，就是砍掉前3组8位

**10000010**

③ 根据运算后的补码，反向推原码 				④ 使用8421码开始计算

![image-20220704093233903](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220704093233903.png)

### **4.位运算符**

**位运算符介绍**

⚫ 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。

⚫ 在二进制位运算中，1表示true，0表示false。  **&：与**     **|：或**     **^：异或**    **~：取反**   

8>>2  = 8/4 = 2

8<<2 = 8*4 = 32

![image-20220704093451780](/assets/blog_res/2022-04-11-JavaEEBase-NO.6-img/image-20220704093451780.png)

**异或运算的特点**

🔴🔴🔴**（面试常见）**

⚫ **一个数，被另外一个数，异或两次，该数本身不变。**

需求：已知两个整数变量a = 10，b = 20，使用程序时间这两个变量的数据交换

最终输出a = 20，b = 10;

<u>不允许使用三方变量！！！</u>

```Java
public static void main(String[] args) {
	int a = 10;
	int b = 20;
	a = a ^ b;                 // a = 10 ^ 20;
	b = a ^ b;                 // b = 10 ^ 20 ^ 20;
	a = a ^ b;                 // a = 10 ^ 20 ^ 10;
	System.out.println(a);
	System.out.println(b);
}
```





## 二、二维数组

**什么是二维数组**

⚫ 二维数组也是一种**容器**，不同于一维数组，该容器存储的都是一维数组容器

**二维数组初始化之动态初始化**

### **1.二维数组定义格式**

⚫ 格式1：数据类型 [ ] [ ] 变量名; 

⚫ 范例：int [ ] [ ] arr; 

⚫ 格式2：数据类型 变量名[ ] [ ];

⚫ 格式3：数据类型[ ] 变量名[ ];

⚫ 范例：int arr[ ] [ ];

⚫ 范例：int[ ] arr[ ];

### **2.二维数组动态初始化**

⚫ 格式：数据类型 [ ] [ ] 变量名 = new 数据类型[ m ] [ n ];

m表示这个二维数组，可以存放多少个一维数组

n表示每一个一维数组，可以存放多少个元素

⚫ 范例：int [ ] [ ] arr = new int [ 2 ] [ 3 ];

该数组可以存放2个一维数组，每个一维数组中可以存放3个int类型元素

### **3.二维数组静态初始化**

⚫ 格式：数据类型 [ ] [ ] 变量名 = new 数据类型[ ] [ ] { {元素1,元素2}, {元素1, 元素2} };

⚫ 范例：int [ ] [ ] arr = new int [ ][ ] { {11,22} , {33,44} };

⚫ 简化格式：数据类型 [ ] [ ] 变量名 = { {元素1,元素2}, {元素1, 元素2} };

⚫ 范例：int [ ] [ ] arr = { {11,22} , {33,44} };

### **4.元素访问**

获取二维数组中的一维数组 ： 数组名[索引]

获取二维数组中某个一维数组中的元素:  数组名[n] [m]  

​			n: 你想获取的一维数组的索引

​			m: 一维数组中元素的索引

表示二维数组arr中的第一个一维数组里面的第2个元素 : arr[0] [1]

表示二维数组arr中的第三个一维数组里面的第4个元素 ：arr[2] [3]

### **5.遍历**

```java
// int[][] arr = {{11, 22, 33}, {33, 44, 55}};  此处由于上传GitHub出错因此注释处理。

    // 1. 遍历二维数组，取出里面每一个一维数组

    for (int i = 0; i < arr.length; i++) {

      //System.out.println(arr[i]);

      // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素

      //int[] temp = arr[i];

      for (int j = 0; j < arr[i].length; j++) {

        System.out.println(arr[i][j]);

      }

    }
```

 

### **6.二维数组求和**

```java
public class Test03 {
    public static void main(String[] args) {
    //    int[][] arr = {{11,22,33},{44,45,56},{1,2,3},{1,2,3}};   此处由于上传GitHub出错因此注释处理。
        //定义求和变量sum
        int sum = 0;
        //遍历二维数组的每个数据  加到sum上
        for (int i = 0; i < arr.length; i++) {
            int[] newArr = arr[i];
            for (int j = 0; j < newArr.length; j++) {
                sum += newArr[j];
            }
        }
        System.out.println(sum);
    }
}
```

