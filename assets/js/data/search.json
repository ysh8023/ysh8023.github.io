[ { "title": "单列模式-->懒汉&饿汉", "url": "/posts/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F-%E6%87%92%E6%B1%89&%E9%A5%BF%E6%B1%89/", "categories": "Java学习", "tags": "Java学习补充总结", "date": "2022-09-05 05:13:45 +0000", "snippet": "单列模式： 可以保证系统中应用该模式的这个类永远只有一个实例 即一个类永远只能创建一个对象饿汉单列设计模式​\t定义：在类获取对象的时候，对象已经提前创建好了。​\t设计步骤： 定义一个类，把构造器私有 定义一个静态变量存储对象 /**\t使用饿汉单列实现单列类*/public class SingleInstance{ /** 饿汉单列是在获取对象前，对象已经提前准备好了一个 这个对象只能是一个 所以定义静态成员变量 */ public static SingleInstance instance = new SingleInstance; /** 必须把构造器私有化 */ private SingleInstance(){ }}懒汉单列设计模式 在真正需要该对象的的时候，才去创建一个对象（延迟加载对象）设计步骤： 定义一个类，把构造器私有 定义一个静态变量存储一个对象 提供一个返回单列对象的方法//懒汉单列设计模式public class SingleInstance2 { /** 定义一个静态成员变量负责存储一个对象。 只加载一次 只有一份 注意：此静态成员变量应该私有化。 */ private static SingleInstance2 instance = null; \t/** \t提供一个方法 对外返回单列对象 \t*/ \tpublic static SingleInstance2 getInstance(){ if(instance == null ){ //第一次来拿对象 此时需要创建对象 instance = new SingleInstance2(); } return instance; } \t/** \t私有化构造器 \t*/\t\tprivate SingleInstance2(){ } ❔本文仅为笔者个人学习总结， 欲详细学习可访问👉菜鸟教程 单列模式🔈[菜鸟教程 单列模式](https://www.runoob.com/design-pattern/singleton-pattern.html) " }, { "title": "JDK1.8 新特性", "url": "/posts/JDK1.8-%E6%96%B0%E7%89%B9%E6%80%A7/", "categories": "JAVA学习总结", "tags": "学习总结", "date": "2022-08-29 02:34:00 +0000", "snippet": "JDK1.8 新特性本文主要介绍了JDK1.8版本中的一些新特性，乃作者学习JAVA后笔记，仅供参考。jdk1.8新特性知识点： Lambda表达式 函数式接口 *方法引用和构造器调用 Stream API 接口中的默认方法和静态方法 新时间日期API 在jdk1.8中对hashMap等map集合的数据结构优化。hashMap数据结构的优化原来的hashMap采用的数据结构是哈希表（数组+链表），hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面，形成一个链表，形成了碰撞，在某些情况下如果链表无限下去，那么效率极低，碰撞是避免不了的加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生在1.8之后，在数组+链表+红黑树来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有红黑树的引入除了添加之后，效率都比链表高，1.8之后链表新进元素加到末尾ConcurrentHashMap (锁分段机制)，concurrentLevel,jdk1.8采用CAS算法(无锁算法，不再使用锁分段)，数组+链表中也引入了红黑树的使用Lambda表达式 lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码先来体验一下lambda最直观的优点：简洁代码 //匿名内部类 Comparator&lt;Integer&gt; cpt = new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1,o2); } }; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(cpt); System.out.println(\"=========================\"); //使用lambda表达式 Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y); TreeSet&lt;Integer&gt; set2 = new TreeSet&lt;&gt;(cpt2);只需要一行代码，极大减少代码量！！这样一个场景，在商城浏览商品信息时，经常会有条件的进行筛选浏览，例如要选颜色为红色的、价格小于8000千的….// 筛选颜色为红色public List&lt;Product&gt; filterProductByColor(List&lt;Product&gt; list){ List&lt;Product&gt; prods = new ArrayList&lt;&gt;(); for (Product product : list){ if (\"红色\".equals(product.getColor())){ prods.add(product); } } return prods; }// 筛选价格小于8千的public List&lt;Product&gt; filterProductByPrice(List&lt;Product&gt; list){ List&lt;Product&gt; prods = new ArrayList&lt;&gt;(); for (Product product : list){ if (product.getPrice() &lt; 8000){ prods.add(product); } } return prods; }我们发现实际上这些过滤方法的核心就只有if语句中的条件判断，其他均为模版代码，每次变更一下需求，都需要新增一个方法，然后复制黏贴，假设这个过滤方法有几百行，那么这样的做法难免笨拙了一点。如何进行优化呢？优化一：使用设计模式定义一个MyPredicate接口public interface MyPredicate &lt;T&gt; { boolean test(T t);}如果想要筛选颜色为红色的商品，定义一个颜色过滤类public class ColorPredicate implements MyPredicate &lt;Product&gt; { private static final String RED = \"红色\"; @Override public boolean test(Product product) { return RED.equals(product.getColor()); }定义过滤方法，将过滤接口当做参数传入，这样这个过滤方法就不用修改，在实际调用的时候将具体的实现类传入即可。public List&lt;Product&gt; filterProductByPredicate(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp){ List&lt;Product&gt; prods = new ArrayList&lt;&gt;(); for (Product prod : list){ if (mp.test(prod)){ prods.add(prod); } } return prods; }例如，如果想要筛选价格小于8000的商品，那么新建一个价格过滤类既可public class PricePredicate implements MyPredicate&lt;Product&gt; { @Override public boolean test(Product product) { return product.getPrice() &lt; 8000; }}这样实现的话可能有人会说，每次变更需求都需要新建一个实现类，感觉还是有点繁琐呀，那么再来优化一下优化二：使用匿名内部类定义过滤方法：public List&lt;Product&gt; filterProductByPredicate(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp){ List&lt;Product&gt; prods = new ArrayList&lt;&gt;(); for (Product prod : list){ if (mp.test(prod)){ prods.add(prod); } } return prods; }调用过滤方法的时候：// 按价格过滤public void test2(){ filterProductByPredicate(proList, new MyPredicate&lt;Product&gt;() { @Override public boolean test(Product product) { return product.getPrice() &lt; 8000; } });} // 按颜色过滤 public void test3(){ filterProductByPredicate(proList, new MyPredicate&lt;Product&gt;() { @Override public boolean test(Product product) { return \"红色\".equals(product.getColor()); } }); }使用匿名内部类，就不需要每次都新建一个实现类，直接在方法内部实现。看到匿名内部类，不禁想起了Lambda表达式。优化三：使用lambda表达式定义过滤方法：public List&lt;Product&gt; filterProductByPredicate(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp){ List&lt;Product&gt; prods = new ArrayList&lt;&gt;(); for (Product prod : list){ if (mp.test(prod)){ prods.add(prod); } } return prods; }使用lambda表达式进行过滤@Testpublic void test4(){ List&lt;Product&gt; products = filterProductByPredicate(proList, (p) -&gt; p.getPrice() &lt; 8000); for (Product pro : products){ System.out.println(pro); } }在jdk1.8中还有更加简便的操作 Stream API优化四：使用Stream API甚至不用定义过滤方法，直接在集合上进行操作// 使用jdk1.8中的Stream API进行集合的操作@Testpublic void test(){ // 根据价格过滤 proList.stream() .fliter((p) -&gt; p.getPrice() &lt;8000) .limit(2) .forEach(System.out::println); // 根据颜色过滤 proList.stream() .fliter((p) -&gt; \"红色\".equals(p.getColor())) .forEach(System.out::println); // 遍历输出商品名称 proList.stream() .map(Product::getName) .forEach(System.out::println);}Lmabda表达式的语法总结： () -&gt; (); 前置 语法 无参数无返回值 () -&gt; System.out.println(“Hello WOrld”) 有一个参数无返回值 (x) -&gt; System.out.println(x) 有且只有一个参数无返回值 x -&gt; System.out.println(x) 有多个参数，有返回值，有多条lambda体语句 (x，y) -&gt; {System.out.println(“xxx”);return xxxx;}； 有多个参数，有返回值，只有一条lambda体语句 (x，y) -&gt; xxxx 口诀：左右遇一省括号，左侧推断类型省注：当一个接口中存在多个抽象方法时，如果使用lambda表达式，并不能智能匹配对应的抽象方法，因此引入了函数式接口的概念函数式接口 函数式接口的提出是为了给Lambda表达式的使用提供更好的支持。什么是函数式接口？简单来说就是只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface常见的四大函数式接口 Consumer 《T》：消费型接口，有参无返回值 @Test public void test(){ changeStr(\"hello\",(str) -&gt; System.out.println(str)); } /** * Consumer&lt;T&gt; 消费型接口 * @param str * @param con */ public void changeStr(String str, Consumer&lt;String&gt; con){ con.accept(str); } Supplier 《T》：供给型接口，无参有返回值 @Test public void test2(){ String value = getValue(() -&gt; \"hello\"); System.out.println(value); } /** * Supplier&lt;T&gt; 供给型接口 * @param sup * @return */ public String getValue(Supplier&lt;String&gt; sup){ return sup.get(); } Function 《T,R》：:函数式接口，有参有返回值 @Test public void test3(){ Long result = changeNum(100L, (x) -&gt; x + 200L); System.out.println(result); } /** * Function&lt;T,R&gt; 函数式接口 * @param num * @param fun * @return */ public Long changeNum(Long num, Function&lt;Long, Long&gt; fun){ return fun.apply(num); } Predicate《T》： 断言型接口，有参有返回值，返回值是boolean类型public void test4(){ boolean result = changeBoolean(\"hello\", (str) -&gt; str.length() &gt; 5); System.out.println(result); } /** * Predicate&lt;T&gt; 断言型接口 * @param str * @param pre * @return */ public boolean changeBoolean(String str, Predicate&lt;String&gt; pre){ return pre.test(str); }在四大核心函数式接口基础上，还提供了诸如BiFunction、BinaryOperation、toIntFunction等扩展的函数式接口，都是在这四种函数式接口上扩展而来的，不做赘述。总结：函数式接口的提出是为了让我们更加方便的使用lambda表达式，不需要自己再手动创建一个函数式接口，直接拿来用就好了，贴方法引用 若lambda体中的内容有方法已经实现了，那么可以使用“方法引用”也可以理解为方法引用是lambda表达式的另外一种表现形式并且其语法比lambda表达式更加简单(a) 方法引用三种表现形式： 对象：：实例方法名 类：：静态方法名 类：：实例方法名 （lambda参数列表中第一个参数是实例方法的调用 者，第二个参数是实例方法的参数时可用） public void test() { /** *注意： * 1.lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保持一致！ * 2.若lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method * */ Consumer&lt;Integer&gt; con = (x) -&gt; System.out.println(x); con.accept(100); // 方法引用-对象::实例方法 Consumer&lt;Integer&gt; con2 = System.out::println; con2.accept(200); // 方法引用-类名::静态方法名 BiFunction&lt;Integer, Integer, Integer&gt; biFun = (x, y) -&gt; Integer.compare(x, y); BiFunction&lt;Integer, Integer, Integer&gt; biFun2 = Integer::compare; Integer result = biFun2.apply(100, 200); // 方法引用-类名::实例方法名 BiFunction&lt;String, String, Boolean&gt; fun1 = (str1, str2) -&gt; str1.equals(str2); BiFunction&lt;String, String, Boolean&gt; fun2 = String::equals; Boolean result2 = fun2.apply(\"hello\", \"world\"); System.out.println(result2); }(b)构造器引用格式：ClassName::newpublic void test2() { // 构造方法引用 类名::new Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); System.out.println(sup.get()); Supplier&lt;Employee&gt; sup2 = Employee::new; System.out.println(sup2.get()); // 构造方法引用 类名::new （带一个参数） Function&lt;Integer, Employee&gt; fun = (x) -&gt; new Employee(x); Function&lt;Integer, Employee&gt; fun2 = Employee::new; System.out.println(fun2.apply(100)); }(c)数组引用格式：Type[]::newpublic void test(){ // 数组引用 Function&lt;Integer, String[]&gt; fun = (x) -&gt; new String[x]; Function&lt;Integer, String[]&gt; fun2 = String[]::new; String[] strArray = fun2.apply(10); Arrays.stream(strArray).forEach(System.out::println);}Stream APIStream操作的三个步骤 创建stream 中间操作（过滤、map） 终止操作stream的创建： // 1，校验通过Collection 系列集合提供的stream()或者paralleStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Strean&lt;String&gt; stream1 = list.stream(); // 2.通过Arrays的静态方法stream()获取数组流 String[] str = new String[10]; Stream&lt;String&gt; stream2 = Arrays.stream(str); // 3.通过Stream类中的静态方法of Stream&lt;String&gt; stream3 = Stream.of(\"aa\",\"bb\",\"cc\"); // 4.创建无限流 // 迭代 Stream&lt;Integer&gt; stream4 = Stream.iterate(0,(x) -&gt; x+2); //生成 Stream.generate(() -&gt;Math.random());Stream的中间操作:/** * 筛选 过滤 去重 */ emps.stream() .filter(e -&gt; e.getAge() &gt; 10) .limit(4) .skip(4) // 需要流中的元素重写hashCode和equals方法 .distinct() .forEach(System.out::println); /** * 生成新的流 通过map映射 */ emps.stream() .map((e) -&gt; e.getAge()) .forEach(System.out::println); /** * 自然排序 定制排序 */ emps.stream() .sorted((e1 ,e2) -&gt; { if (e1.getAge().equals(e2.getAge())){ return e1.getName().compareTo(e2.getName()); } else{ return e1.getAge().compareTo(e2.getAge()); } }) .forEach(System.out::println);Stream的终止操作： /** * 查找和匹配 * allMatch-检查是否匹配所有元素 * anyMatch-检查是否至少匹配一个元素 * noneMatch-检查是否没有匹配所有元素 * findFirst-返回第一个元素 * findAny-返回当前流中的任意元素 * count-返回流中元素的总个数 * max-返回流中最大值 * min-返回流中最小值 */ /** * 检查是否匹配元素 */ boolean b1 = emps.stream() .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); System.out.println(b1); boolean b2 = emps.stream() .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); System.out.println(b2); boolean b3 = emps.stream() .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY)); System.out.println(b3); Optional&lt;Employee&gt; opt = emps.stream() .findFirst(); System.out.println(opt.get()); // 并行流 Optional&lt;Employee&gt; opt2 = emps.parallelStream() .findAny(); System.out.println(opt2.get()); long count = emps.stream() .count(); System.out.println(count); Optional&lt;Employee&gt; max = emps.stream() .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(max.get()); Optional&lt;Employee&gt; min = emps.stream() .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(min.get());还有功能比较强大的两个终止操作 reduce和collectreduce操作： reduce:(T identity,BinaryOperator)/reduce(BinaryOperator)-可以将流中元素反复结合起来，得到一个值 /** * reduce ：规约操作 */ List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer count2 = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(count2); Optional&lt;Double&gt; sum = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(sum);collect操作：Collect-将流转换为其他形式，接收一个Collection接口的实现，用于给Stream中元素做汇总的方法 /** * collect：收集操作 */ List&lt;Integer&gt; ageList = emps.stream() .map(Employee::getAge) .collect(Collectors.toList()); ageList.stream().forEach(System.out::println);并行流和串行流在jdk1.8新的stream包中针对集合的操作也提供了并行操作流和串行操作流。并行流就是把内容切割成多个数据块，并且使用多个线程分别处理每个数据块的内容。Stream api中声明可以通过parallel()与sequential()方法在并行流和串行流之间进行切换。jdk1.8并行流使用的是fork/join框架进行并行操作ForkJoin框架Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。关键字：递归分合、分而治之。采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.。/** * 要想使用Fark—Join，类必须继承 * RecursiveAction（无返回值） * Or * RecursiveTask（有返回值）**/public class ForkJoin extends RecursiveTask&lt;Long&gt; { /** * 要想使用Fark—Join，类必须继承RecursiveAction（无返回值） 或者 * RecursiveTask（有返回值） * * @author Wuyouxin */ private static final long serialVersionUID = 23423422L; private long start; private long end; public ForkJoin() { } public ForkJoin(long start, long end) { this.start = start; this.end = end; } // 定义阙值 private static final long THRESHOLD = 10000L; @Override protected Long compute() { if (end - start &lt;= THRESHOLD) { long sum = 0; for (long i = start; i &lt; end; i++) { sum += i; } return sum; } else { long middle = (end - start) / 2; ForkJoin left = new ForkJoin(start, middle); //拆分子任务，压入线程队列 left.fork(); ForkJoin right = new ForkJoin(middle + 1, end); right.fork(); //合并并返回 return left.join() + right.join(); } } /** * 实现数的累加 */ @Test public void test1() { //开始时间 Instant start = Instant.now(); //这里需要一个线程池的支持 ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoin(0L, 10000000000L); // 没有返回值 pool.execute(); // 有返回值 long sum = pool.invoke(task); //结束时间 Instant end = Instant.now(); System.out.println(Duration.between(start, end).getSeconds()); } /** * java8 并行流 parallel() */ @Test public void test2() { //开始时间 Instant start = Instant.now(); // 并行流计算 累加求和 LongStream.rangeClosed(0, 10000000000L).parallel() .reduce(0, Long :: sum); //结束时间 Instant end = Instant.now(); System.out.println(Duration.between(start, end).getSeconds()); } @Test public void test3(){ List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); list.stream().forEach(System.out::print); list.parallelStream() .forEach(System.out::print); }展示多线程的效果：@Test public void test(){ // 并行流 多个线程执行 List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); numbers.parallelStream() .forEach(System.out::print); // System.out.println(\"=========================\"); numbers.stream() .sequential() .forEach(System.out::print); }Optional容器使用Optional容器可以快速的定位NPE，并且在一定程度上可以减少对参数非空检验的代码量。1/** * Optional.of(T t); // 创建一个Optional实例 * Optional.empty(); // 创建一个空的Optional实例 * Optional.ofNullable(T t); // 若T不为null，创建一个Optional实例，否则创建一个空实例 * isPresent(); // 判断是够包含值 * orElse(T t); //如果调用对象包含值，返回该值，否则返回T * orElseGet(Supplier s); // 如果调用对象包含值，返回该值，否则返回s中获取的值 * map(Function f): // 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty(); * flatMap(Function mapper);// 与map类似。返回值是Optional * * 总结：Optional.of(null) 会直接报NPE */Optional&lt;Employee&gt; op = Optional.of(new Employee(\"zhansan\", 11, 12.32, Employee.Status.BUSY)); System.out.println(op.get()); // NPE Optional&lt;Employee&gt; op2 = Optional.of(null); System.out.println(op2);@Test public void test2(){ Optional&lt;Object&gt; op = Optional.empty(); System.out.println(op); // No value present System.out.println(op.get()); }@Test public void test3(){ Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee(\"lisi\", 33, 131.42, Employee.Status.FREE)); System.out.println(op.get()); Optional&lt;Object&gt; op2 = Optional.ofNullable(null); System.out.println(op2); // System.out.println(op2.get()); } @Test public void test5(){ Optional&lt;Employee&gt; op1 = Optional.ofNullable(new Employee(\"张三\", 11, 11.33, Employee.Status.VOCATION)); System.out.println(op1.orElse(new Employee())); System.out.println(op1.orElse(null)); } @Test public void test6(){ Optional&lt;Employee&gt; op1 = Optional.of(new Employee(\"田七\", 11, 12.31, Employee.Status.BUSY)); op1 = Optional.empty(); Employee employee = op1.orElseGet(() -&gt; new Employee()); System.out.println(employee); } @Test public void test7(){ Optional&lt;Employee&gt; op1 = Optional.of(new Employee(\"田七\", 11, 12.31, Employee.Status.BUSY)); System.out.println(op1.map( (e) -&gt; e.getSalary()).get()); }接口中可以定义默认实现方法和静态方法在接口中可以使用default和static关键字来修饰接口中定义的普通方法public interface Interface { default String getName(){ return \"zhangsan\"; } static String getName2(){ return \"zhangsan\"; }}在JDK1.8中很多接口会新增方法，为了保证1.8向下兼容，1.7版本中的接口实现类不用每个都重新实现新添加的接口方法，引入了default默认实现，static的用法是直接用接口名去调方法即可。当一个类继承父类又实现接口时，若后两者方法名相同，则优先继承父类中的同名方法，即“类优先”，如果实现两个同名方法的接口，则要求实现类必须手动声明默认实现哪个接口中的方法。新的日期API LocalDate | LocalTime | LocalDateTime新的日期API都是不可变的，更使用于多线程的使用环境中 @Test public void test(){ // 从默认时区的系统时钟获取当前的日期时间。不用考虑时区差 LocalDateTime date = LocalDateTime.now(); //2018-07-15T14:22:39.759 System.out.println(date); System.out.println(date.getYear()); System.out.println(date.getMonthValue()); System.out.println(date.getDayOfMonth()); System.out.println(date.getHour()); System.out.println(date.getMinute()); System.out.println(date.getSecond()); System.out.println(date.getNano()); // 手动创建一个LocalDateTime实例 LocalDateTime date2 = LocalDateTime.of(2017, 12, 17, 9, 31, 31, 31); System.out.println(date2); // 进行加操作，得到新的日期实例 LocalDateTime date3 = date2.plusDays(12); System.out.println(date3); // 进行减操作，得到新的日期实例 LocalDateTime date4 = date3.minusYears(2); System.out.println(date4); } @Test public void test2(){ // 时间戳 1970年1月1日00：00：00 到某一个时间点的毫秒值 // 默认获取UTC时区 Instant ins = Instant.now(); System.out.println(ins); System.out.println(LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli()); System.out.println(System.currentTimeMillis()); System.out.println(Instant.now().toEpochMilli()); System.out.println(Instant.now().atOffset(ZoneOffset.ofHours(8)).toInstant().toEpochMilli()); } @Test public void test3(){ // Duration:计算两个时间之间的间隔 // Period：计算两个日期之间的间隔 Instant ins1 = Instant.now(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Instant ins2 = Instant.now(); Duration dura = Duration.between(ins1, ins2); System.out.println(dura); System.out.println(dura.toMillis()); System.out.println(\"======================\"); LocalTime localTime = LocalTime.now(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } LocalTime localTime2 = LocalTime.now(); Duration du2 = Duration.between(localTime, localTime2); System.out.println(du2); System.out.println(du2.toMillis()); }@Test public void test4(){ LocalDate localDate =LocalDate.now(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } LocalDate localDate2 = LocalDate.of(2016,12,12); Period pe = Period.between(localDate, localDate2); System.out.println(pe); } @Test public void test5(){ // temperalAdjust 时间校验器 // 例如获取下周日 下一个工作日 LocalDateTime ldt1 = LocalDateTime.now(); System.out.println(ldt1); // 获取一年中的第一天 LocalDateTime ldt2 = ldt1.withDayOfYear(1); System.out.println(ldt2); // 获取一个月中的第一天 LocalDateTime ldt3 = ldt1.withDayOfMonth(1); System.out.println(ldt3); LocalDateTime ldt4 = ldt1.with(TemporalAdjusters.next(DayOfWeek.FRIDAY)); System.out.println(ldt4); // 获取下一个工作日 LocalDateTime ldt5 = ldt1.with((t) -&gt; { LocalDateTime ldt6 = (LocalDateTime)t; DayOfWeek dayOfWeek = ldt6.getDayOfWeek(); if (DayOfWeek.FRIDAY.equals(dayOfWeek)){ return ldt6.plusDays(3); } else if (DayOfWeek.SATURDAY.equals(dayOfWeek)){ return ldt6.plusDays(2); } else { return ldt6.plusDays(1); } }); System.out.println(ldt5); } @Test public void test6(){ // DateTimeFormatter: 格式化时间/日期 // 自定义格式 LocalDateTime ldt = LocalDateTime.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\"); String strDate1 = ldt.format(formatter); String strDate = formatter.format(ldt); System.out.println(strDate); System.out.println(strDate1); // 使用api提供的格式 DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE; LocalDateTime ldt2 = LocalDateTime.now(); String strDate3 = dtf.format(ldt2); System.out.println(strDate3); // 解析字符串to时间 DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); LocalDateTime time = LocalDateTime.now(); String localTime = df.format(time); LocalDateTime ldt4 = LocalDateTime.parse(\"2017-09-28 17:07:05\",df); System.out.println(\"LocalDateTime转成String类型的时间：\"+localTime); System.out.println(\"String类型的时间转成LocalDateTime：\"+ldt4); } // ZoneTime ZoneDate ZoneDateTime @Test public void test7(){ LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(now); LocalDateTime now2 = LocalDateTime.now(); ZonedDateTime zdt = now2.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); set.stream().forEach(System.out::println); }补充： 表示日期的LocalDate表示时间的LocalTime表示日期时间的LocalDateTime新的日期API的几个优点： * 之前使用的java.util.Date月份从0开始，我们一般会+1使用，很不方便，java.time.LocalDate月份和星期都改成了enum * java.util.Date和SimpleDateFormat都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。 * java.util.Date是一个“万能接口”，它包含日期、时间，还有毫秒数，更加明确需求取舍 * 新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。 LocalDatepublic static void localDateTest() { //获取当前日期,只含年月日 固定格式 yyyy-MM-dd 2018-05-04 LocalDate today = LocalDate.now(); // 根据年月日取日期，5月就是5， LocalDate oldDate = LocalDate.of(2018, 5, 1); // 根据字符串取：默认格式yyyy-MM-dd，02不能写成2 LocalDate yesteday = LocalDate.parse(\"2018-05-03\"); // 如果不是闰年 传入29号也会报错 LocalDate.parse(\"2018-02-29\"); } LocalDate常用转化 /** * 日期转换常用,第一天或者最后一天... */ public static void localDateTransferTest(){ //2018-05-04 LocalDate today = LocalDate.now(); // 取本月第1天： 2018-05-01 LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 取本月第2天：2018-05-02 LocalDate secondDayOfThisMonth = today.withDayOfMonth(2); // 取本月最后一天，再也不用计算是28，29，30还是31： 2018-05-31 LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); // 取下一天：2018-06-01 LocalDate firstDayOf2015 = lastDayOfThisMonth.plusDays(1); // 取2018年10月第一个周三 so easy?： 2018-10-03 LocalDate thirdMondayOf2018 = LocalDate.parse(\"2018-10-01\").with(TemporalAdjusters.firstInMonth(DayOfWeek.WEDNESDAY)); } LocalTime public static void localTimeTest(){ //16:25:46.448(纳秒值) LocalTime todayTimeWithMillisTime = LocalTime.now(); //16:28:48 不带纳秒值 LocalTime todayTimeWithNoMillisTime = LocalTime.now().withNano(0); LocalTime time1 = LocalTime.parse(\"23:59:59\"); } LocalDateTimepublic static void localDateTimeTest(){ //转化为时间戳 毫秒值 long time1 = LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli(); long time2 = System.currentTimeMillis(); //时间戳转化为localdatetime DateTimeFormatter df= DateTimeFormatter.ofPattern(\"YYYY-MM-dd HH:mm:ss.SSS\"); System.out.println(df.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(time1),ZoneId.of(\"Asia/Shanghai\")))); }路漫漫其修远兮，吾将上下而求索。🚀" }, { "title": "啥是IDM？", "url": "/posts/IDM%E6%98%AF%E4%B8%AA%E5%95%A5/", "categories": "技术分享", "tags": "技术分享", "date": "2022-08-29 02:34:00 +0000", "snippet": "IDM是个啥知己知彼IDM是个强大的脚本插件，IDM脚本在资本主义日渐猖獗的背景下，被互联网大佬们创作出来，主要作用于百度网盘的下载限速的问题。 百度网盘如今店大欺客，限制下载速度不是一年两年了，早就引发社会主义人民的众怒，IDM的问世，就是善良的社会主义人民的”重拳出击”，狠狠的打了丑恶资本主义的一个大逼兜。如何习得“重拳”技能？先下载油猴油猴下载地址下载过程点击下载（黑色的那个）点击安装（点Add to Firefox）点击添加（添加A）好的油猴安装后浏览器扩展多个 鼻孔 似的的图标（右边第一排倒数第二个）点击鼻孔（选择获取新脚本）在搜索框直接搜百度网盘选择如图 网盘直链下载助手，千万不要下载错了点击安装再点击安装跳到这之后不用点安装了，到这一步就算成了。注意！油猴是一个开放性的脚本管理插件系统，所以油猴里的部分脚本或部分扩展有不确定性，可能含有威胁，不要随意下载使用。安装IDM云盘提取：IDM 提取码（idm6）提取完得到一个压缩包，解压到你想解压的地方。解压完之后得到一个目录长这样👇👇👇注意！安装完之后就行了，不用管了。看到绿化这两个字眼，应该都能明白什么意思，懂得都懂。不懂点这如何使用”重拳“技能？随便找个百度网盘资源连接，到刚刚安装好油猴的浏览器打开它，你会发现你的百度网盘资源下载界面多了个下载助手。点击API下载点击如图链接（因为第一次使用，所以响应比较慢，稍等一会就好了）之后刚刚安装好的IDM就会弹出文件下载信息，可以选择下载路径可以看到下载速度6.499MB/秒，速度还是很理想的。总结Templemonkey是一个可以让Chrome支持更多chrome不支持的脚本的Chrome扩展 ，Temple monkey里面有很多脚本，包括网盘直链下载助手脚本。idm是个资源下载管理器说白了就是个资源下载管理器， idm可以捕捉到网页中存在的资源并提示下载， 它可以利用多线程提高用户所占服务器的宽带，但是如果资源本身就做了低速处理，或者宽带的速度本来就并不快 idm就算再🐂🍺也突破不了这些限制。在浏览器没有安装油猴里面的网盘直链下载助手脚本时，idm是不能捕捉到网页资源的，因为资源本身做了限制，脚本的作用就是突破这些限制，能让idm捕捉到网页的资源!" }, { "title": "NO.09 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.9/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-04-20 14:31:34 +0000", "snippet": "NO.09 Java基础学习&amp;心得体会一、集合基础1、集合概述集合就是用来存储多个数据的容器直接打印String StringBulider list 可以直接打印出里面的数据。注：用equal方法的时候 尽量用常量.equal(变量)集合和数组的特点对比⚫ 集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变⚫ 集合和数组的区别：​\t\t⚫ 共同点：都是存储数据的容器​\t\t⚫ 不同点：数组的容量是固定的，集合的容量是可变的2、ArrayList集合类有很多，先学习：ArrayList①、构造方法**ArrayList list = new ArrayList();**集合容器如果没有加入&lt;&gt; 就可以存储任意数据类型&lt;&gt; 泛型: 对集合容器存储的数据类型进行限制 ，这里面的数据类型只能是引用数据类型②、添加元素​ 1️⃣ boolean add(E e) 将指定的元素添加到此列表的尾部。​ 2️⃣ void add(int index, E element) 将指定的元素插入此列表中的指定位置。 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //添加元素 list.add(\"cj\",); list.add(\"cj2\"); list.add(\"cj3\"); list.add(\"黑马52\"); System.out.println(list); //[\"cj\",\"cj2\",\"cj3\",\"黑马52\"]③、成员方法列子： public static void main(String[] args) {// int[] arr = {1,2,3,4}; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //添加元素 list.add(\"剑圣\"); list.add(\"盲僧\"); list.add(\"瑞文\");// for(int i = 0;i&lt;list.size();i++){// String s = list.get(i);//// System.out.println(s);// }// list.add(2,\"TIMU\");//// //删除元素// list.remove(0); list.remove(\"TIMU111\");//// //获取元素// String s = list.get(0);// System.out.println(s);////// //修改// list.set(0,\"瞎子\");//// //获取集合大小// System.out.println(list.size()); }方法名 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t说明public boolean remove(Object o) \t\t\t\t\t\t\t\t\t\t删除指定的元素，返回删除是否成功public E remove(int index) \t\t\t\t\t\t\t\t\t\t\t\t\t删除指定索引处的元素，返回被删除的元素public E set(int index,E element) \t\t\t\t\t\t\t\t\t\t修改指定索引处的元素，返回被修改的元素public E get(int index) \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t返回指定索引处的元素public int size() \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t返回集合中的元素的个数④、遍历集合列子： ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"瑞文\"); list.add(\"盖伦\"); list.add(\"玛尔扎哈\"); for(int i = 0;i&lt;list.size();i++){ String s = list.get(i); System.out.println(s); }" }, { "title": "NO.08 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.8/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-04-17 13:35:45 +0000", "snippet": "NO.08 Java基础学习&amp;心得体会一、字符串1、APIAPI (Application Programming Interface) ：应用程序编程接口厂商提供给应用程序编程的接口，大家把这些类称为 APIJava API ：指的就是 JDK 中提供的各种功能的 Java类2、String①、String 概述String 类在 java.lang（核心包） 包下，所以使用的时候不需要导包String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象字符串不可变，它们的值在创建后不能被更改②、String 常见构造方法方法名 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t说明public String() \t\t\t\t\t\t\t\t\t 创建一个空白字符串对象，不含有任何内容public String(char[] chs) \t\t\t\t\t 根据字符数组的内容，来创建字符串对象public String(String original) \t\t\t\t根据传入的字符串内容，来创建字符串对象String s = “abc”; \t\t\t\t\t\t\t\t\t 直接赋值的方式创建字符串对象，内容就是abc③、==创建字符串对象的区别对比==1️⃣以“ ”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串常量池中维护⚫ 字符串常量池（JDK7后在堆内存）：当使用双引号创建字符串对象的时候，系统会检查该字符串是否在字符串常量池中存在​\t\t\t\t\t不存在：创建\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t存在：不会重新创建，而是直接复用2️⃣通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同💨结论：双引号创建的字符串对象，在字符串常量池中存储，通过构造方法创建的字符串对象，在堆内存中存储④、String字符串的特点⚫ Java 程序中所有的双引号字符串，都是 String 类的对象⚫ 字符串不可变，它们的值在创建后不能被更改⚫ 虽然 String 的值是不可变的，但是它们可以被共享。调用String的任意成员方法，这个String对象的内容都不会发生变化。最多返回值是变化后的结果⑤、String常见面试题⚫ 问题：下列代码的运行结果是？⑥、字符串的比较1️⃣使用 == 做比较⚫ 基本类型：比较的是数据值是否相同⚫ 引用类型：比较的是地址值是否相同2️⃣字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫：equals()⚫ public boolean equals(Object anObject)：将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串⑦、🔴String的常用方法1.判断两个字符串内容是否相同。区分大小写boolean equals(String s);使用方法： String类型的变量名.equals(另外一个String类型的变量名);2.比较字符串的内容，忽略大小写boolean equalsIgnoreCase(String anotherString);3.获取传入的索引上的对应的字符char charAt(int index);\t4.将字符串拆分为字符数组后返回char[] toCharArray();5.获得字符串的长度int length();6.从指定位置开始截取。默认到末尾。（注：会把截取之后的字符串作为一个新值，需要用一个字符串类型接收）String substring(int index);7.截取指定范围的字符串。包头不包尾。（注：会把截取之后的字符串作为一个新值，需要用一个字符串类型接收）String substring(int start,int end);8.把字符串中的字符’a’全部替换成’b’String replace(char oldStr,char newStr);列如： String s1 = s.replace(\"TMD\",\"***\");9.按照指定规则切割字符串。例如把一个有规律的字符串例如“a,,bcc,,sss”或者 “qw-ww-rrr”分割成一个字符串数组。String[] split(String regex);列如： String[] split = s.split(\"，\");方法总结：​\t1.构造方法String();\t\t\t\t\t\t创建一个内容为空的字符串对象String(char[] arr);\t\t\t\t\t根据传入的字符数组创建一个字符串对象String(char[] arr,int index,int count); \t\t根据传入的字符数组的一部分来创建字符串对象String(byte[] arr);\t\t\t\t\t根据传入的字节数组创建一个字符串对象String(byte[] arr,int index,int count);\t\t\t根据传入的字节数组的一部分来创建字符串对象String(String s);\t\t\t\t\t根据传入的字符串来创建一个字符串对象2.判断功能boolean equals(String s);\t\t\t\t判断两个字符串内容是否相同。区分大小写\tboolean equalsIgnoreCase(String s);\t\t\t判断两个字符串内容是否相同。不区分大小写boolean startsWith(String s);\t\t\t\t判断当前字符串是否以传入的字符串为开头boolean endsWith(String s);\t\t\t\t判断当前字符串是否以传入的字符串为结尾boolean contains(String s);\t\t\t\t判断当前字符串中是否包含传入的字符串boolean isEmpty();\t\t\t\t\t判断字符串是否为空3.获取功能int length();\t\t\t\t\t\t获取字符串的长度char charAt(int index);\t\t\t\t\t获取传入的索引上的对应的字符int indexOf(String s);\t\t\t\t\t获取传入的字符串在当前字符串中第一次出现的索引位置int lastIndexOf(String s);\t\t\t\t获取传入的字符串在当前字符串中最后一次出现的索引位置String concat(String s);\t\t\t\t拼接字符串String substring(int index);\t\t\t\t从指定位置开始截取。默认到末尾String substring(int start,int end);\t\t\t截取指定范围的字符串。包含开始、不包含结束4.转换功能char[] toCharArray();\t\t\t\t\t将字符串转成字符数组byte[] getBytes();\t\t\t\t\t将字符串转成字节数组String replace(String oldStr,String newStr);\t\t用新字符串 替换所有的老字符串String replace(char oldStr,char newStr);\t\t用新字符 替换所有的老字符String toUpperCase();\t\t\t\t\t将字符串转成大写String toLowerCase();\t\t\t\t\t将字符串转成小写5.其他功能String[] split(String regex);\t\t\t\t按照指定规则切割字符串String trim();\t\t\t\t\t\t去除字符串两端的空白3、StringBuilder1.StringBuilder概述StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器⚫ 作用：提高字符串的操作效率2.构造方法无参：StringBuilder sb = new StringBuilder(); \t\t\t\t\t\t创建一个空白可变字符串对象，不含有任何内容有参：StringBuilder sb2 = new StringBuilder(“abc”);\t\t\t 根据字符串的内容，来创建可变字符串对象3.StringBuilder 的常用成员方法StringBuilder append(任意类型) \t\t\t\t\t\t\t向缓冲区添加内容，并返回对象本身StringBuilder reverse() \t\t\t\t\t\t\t\t\t\t返回相反的字符序列String\ttoString() \t\t\t\t\t\t\t\t\t\t\t\t\t把StringBuilder转换成Stringint\tlength() \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t返回值StringBuilder的长度 \t( 字符出现的个数)4.为什么StringBuilder可以提高字符串拼接效率如果用+拼接，每次都会创建一个新的StringBuilder对象，调用append方法，并且最后调用toString方法。如果自己使用StringBuilder来拼接的化，只会创建一个sb对象，调用一次toString方法。5.StringBuilder和String的区别⚫ String ：内容是不可变的⚫ StringBuilder：内容是可变的6.StringBuilder 和 String 相互转化1. StringBuilder 转换为 Stringpublic String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String2. String 转换为 StringBuilderpublic StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder" }, { "title": "NO.07 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.7/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-04-14 14:12:43 +0000", "snippet": "NO.07 Java基础学习&amp;心得体会一、面向对象1、面向对象思想（封装、继承、多态、（抽象））1.什么是面向对象​\t\t面向过程：强调的是过程。也就是完成功能的每一个步骤都需要自己亲力亲为​\t\t面向对象：强调的是对象。也就是让对象帮我们去完成功能2、面向对象的好处​\t\tA：将复杂的事情简单化了​\t\tB：更符合人们思想习惯的思想(懒人思想)​\t\tC：将程序员由执行者变成了指挥者​\t\t举例：​\t\t\t程序中的例子：\t\t\t\t打印数组​\t\t\t\t\t面向过程：自己写代码遍历。在循环中不断的通过数组名配合索引获取元素输出​\t\t\t\t\t面向对象：Arrays.toString()直接打印数组3、面向对象和面向过程的思想对比⚫ 面向过程：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的⚫ 面向对象：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能对象：指客观存在的事物，万物皆对象⚫ 面向对象思想小结： 可观存在的任何一种事物，都可以看做为程序中的对象 使用面向对象思想可以将复杂的问题简单化 将我们从执行者的位置，变成了指挥者 2、什么是类⚫ 类是对现实生活中一类具有共同属性和行为的事物的抽象描述【类】是对事物，也就是对象的一种描述，可以将类理解为一张设计图根据设计图，可以创建出具体存在的事物\t\t\t\t\t\t\t\t根据类去创建对象3、类的组成⚫1️⃣ 属性​\t\t\t\t该事物的各种特征例如黑马学生事物的属性：姓名、年龄、毕业院校…⚫ 2️⃣行为​\t\t\t\t该事物存在的功能（能够做的事情）例如黑马学生事物行为：学习、Java编程开发4、类和对象的关系类：类是对现实生活中一类具有共同属性和行为的事物的抽象对象：是能够看得到摸的着的真实存在的实体​ 💥类是对象的描述 💥对象是类的实体通过类创建对象，一个类可以创建多个对象5、类的定义类的组成： 属性和行为 —–&gt; （成员变量+成员方法）⚫ 属性：在类中通过成员变量来体现（类中方法外的变量）⚫ 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）类的定义步骤：① 定义类② 编写类的成员变量③ 编写类的成员方法 ：不加static 也不加returnpublic class 类名 {\t// 成员变量\t变量1的数据类型 变量1；\t变量2的数据类型 变量2;\t… \t// 成员方法\t方法1;\t方法2;\t…}6、对象的使用对象：是能够看得到摸的着的真实存在的实体创建对象⚫ 格式：类名 对象名 = new 类名();⚫ 范例：Student s = new Student();使用对象使用是在**测试类的主方法**中使用的。1：使用成员变量⚫ 格式：对象名.变量名⚫ 范例：p.name;2：使用成员方法⚫ 格式：对象名.方法名()⚫ 范例：p.study();垃圾回收⚫ 注意：当堆内存中，对象或数组产生的地址，通过任何方式都不能被找到后，就会被判定为内存中的“垃圾”垃圾会被Java垃圾回收器，空闲的时候自动进行清理7、成员变量和局部变量区别：​\t1.定义位置​\t\t成员变量：定义在类中方法外。作用于整个类中​\t\t局部变量：定义在方法内或方法的声明上。作用于方法里​\t2.在内存中的位置​\t\t成员变量：在堆内存中​\t\t局部变量：在栈内存中​\t3.生命周期​\t\t成员变量：随着对象的创建而创建。随着对象的消失而消失​\t\t局部变量：随着方法的调用而创建。随着方法的消失而消失​\t4.初始化值​\t\t成员变量：有默认初始化值​\t\t局部变量：没有默认初始化值。使用之前必须赋值二、封装1、封装是什么封装:​\t\t就是将不想对外暴露的属性隐藏起来，对外提供一些方法供别人去操作，这样可以更安全，也可以提高代码的复用性 隐藏实现细节，仅对外暴露公共的访问方式🐖注：封装是面向对象的三大特征之一。（封装、继承、多态、（抽象））私有仅仅是封装的一种体现⚫ 封装常见的体现：1、私有成员变量，提供setXxx和getXxx方法2、将代码抽取到方法中，这是对代码的一种封装3、将属性抽取到类当中，这是对数据的一种封装⚫ 封装的好处：1、提高了代码的安全性2、提高了代码的复用性2、private关键字⚫ 是一个权限修饰符⚫ 可以修饰成员（成员变量和成员方法）⚫ 被private修饰的成员只能在本类中才能访问针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作⚫ 提供“get变量名()” 方法，用于获取成员变量的值，方法用public修饰⚫ 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰private关键字的使用一个标准类的编写：⚫ 把成员变量用private修饰⚫ 提供对应的setXxx()/getXxx()方法3、thisthis:​\t\tthis可以用来区分局部变量和成员变量同名的问题this代表什么呢?​\t\t代表当前对象的引用。谁来调用这个方法，this就代表谁（局部变量和成员变量如果重名，Java使用的是就近原则。）方法被那个对象调用 方法中的this就是代表那个对象this关键字的作用： 可以调用本类的成员(变量, 方法) 解决局部变量和成员变量的重名问题三、构造方法1.构造方法概述⚫ 构建、创造对象的时候，所调用的方法⚫ 格式：public 类名（）{} 方法名与类名相同，大小写也要一致 没有返回值类型，连void都没有 没有具体的返回值（不能由retrun带回结果数据） ⚫ 执行时机： 创建对象的时候调用，每创建一次对象，就会执行一次构造方法 不能手动调用构造方法 2.构造方法作用⚫ 作用：用于给对象的数据（属性）进行初始化本质作用：创建对象3.构造方法的注意事项① 构造方法的创建​\t\t⚫ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法​\t\t⚫ 如果定义了构造方法，系统将不再提供默认的构造方法② 构造方法的重载​\t\t⚫ 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法③ 推荐的使用方式​\t\t⚫ 无论是否使用，都手动书写无参数构造方法，和带参数构造方法4.构造方法的调用格式:​\t\tnew 类名(参数);四、标准类制作① 成员变量⚫ 使用private修饰② 构造方法⚫ 提供一个无参构造方法 右键—&gt;Generate—&gt;Constructor—&gt;Select None⚫ 提供一个带多个参数的构造方法 右键—&gt;Generate—&gt;Constructor—&gt;Alt+A—&gt;OK③ 成员方法格式： public void 方法名（）{}⚫ 提供每一个成员变量对应的setXxx()/getXxx() 右键—&gt;Generate—&gt;Getter and Setter—&gt;Alt+A—&gt;OK⚫ 提供一个显示对象信息的show()④ 创建对象并为其成员变量赋值的两种方式⚫ 无参构造方法创建对象后使用setXxx()赋值⚫ 使用带参构造方法直接创建带有属性值的对象JavaBean类：封装数据。" }, { "title": "NO.05 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.5/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-04-07 13:22:13 +0000", "snippet": "NO.05 Java基础学习&amp;心得体会一、方法方法概述：⚫ 方法（method）就是一段具有独立功能的代码块，不调用就不执行代码块：在一对大括号中的多行代码作用：可以提高代码的复用性⚫ 方法必须先创建才可以使用，该过程称为方法定义⚫ 方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用❗❗❗方法的定义和调用1、（基础版本）定义格式：public static void 方法名() { // 方法体}调用格式：方法名();2、（带参版本）定义格式：public static void 方法名 (参数 ) { … … }public static void 方法名 (数据类型 变量名,数据类型 变量名2 ) { … … }单个参数： \tpublic static void 方法名 ( 数据类型 变量名 ) { … … }范例（单个参数）： public static void method( int number) { … … }格式（多个参数）： public static void 方法名 ( 数据类型 变量名1,数据类型 变量名2 ，…… ) { … … }范例（多个参数）： public static void getMax( int number1,int number2 ) { … … }方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错方法定义时，多个参数之间使用逗号(,)分隔调用格式：方法名(参数);方法名 ( 变量名/常量值 ) ;method(5);方法名 ( 变量名1/常量值1 ，变量名2/常量值2 ) ;getMax(5,6 ) ; 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错形参：全称形式参数，是指在定义方法时，所声明的参数实参：全称实际参数，调用方法时，实际传入的参数注意事项：方法调用时，形参和实参的数量和类型必须相匹配，否则将出现编译错误2、（通用版本）定义格式⚫ 格式：public static 返回值类型 方法名(参数类型 参数名,参数类型2 参数名2,.....){\t\t\t\t方法体;\t\t\t\treturn 返回值;}🔴注：public static：修饰符。返回值 :就这件事情做完之后的结果返回值类型: 这件事情做完后的结果的数据类型方法名:这件事情的名字，调用方法时使用的标识参数:做这件事情需要的东西参数类型 : 参数的数据类型参数名:就是给参数取的一个名字方法体：完成功能的代码块return :用来返回最终的结果. 两个作用，第一结束当前方法，第二将后面的返回值还给调用处🔴🔴🔴定义方法三要素:(先把这三个要素分析出来再去定义方法)1.返回值类型 (具体功能)2.方法名3.参数(有几个参数?是什么类型?)⚫ 范例：public static int getMax(int a,int b){ int max = a&gt;b?a:b; return max;}调用格式：格式:\t\t最纯粹的格式: \t\t\t\t 方法名(参数1,参数2...);\t\t\t\t注意:传参数的时候方法定义里有几个参数就传几个参数.方法定义的时候参数是什么类型就传什么类型.\t\t\t\t如果方法有返回值，一般是用变量接收返回值，这个变量的数据类型就是返回值类型例如：\tpublic static void test(){} \t\t调用 ： test(); public static void test(int a,int b){} \t调用 :\t\t\t\t\t\tint a = 10;\t\t\t\t\tint b = 20;\t\t\t\t\ttest(a,b);\t public static void test(int[] arr){} \t调用 :\t\t\t\t\t\tint[] arr = {1,2,3,4};\t\t\t\t\ttest(arr); \t\t public static int test(int a,int b){...} \t调用：\t\t\t\tint a = 10;\t\t\t\tint b = 20;\t\t\t\tint r = test(a,b); public static int[] test(int a,int b){...} \t调用：\t\t\t\tint a = 10;\t\t\t\tint b = 20;\t\t\t\tint[] r = test(a,b);\t\t所以,针对有返回值的方法,强烈建议使用赋值调用; //这也是最常用的.注意：⚫ 方法必须先定义后调用，否则程序将报错方法调用过程⚫ 方法没有被调用的时候，都在方法区中的字节码文件(.class)中存储⚫ 方法被调用的时候，需要进入到栈内存中运行栈： 先进后出⚫ 定义方法时，要做到两个明确明确参数：主要是明确参数的类型和数量明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型⚫ 调用方法时void类型的方法，直接调用即可非void类型的方法，推荐用变量接收调用带返回值方法的定义和调用为什么要有带返回值的方法: 经常会根据一个方法产出的结果，来去组织另外一段代码逻辑,为了拿到这个方法产生的结果，就需要定义带有返回值的方法3、带返回值版本：定义格式：public static 结果的数据类型 方法名 (数据类型 变量名1，数据类型 变量名2... ) { return 返回值; //将方法的运行结果返回给调用者}返回值：方法执行完后的结果⚫ 范例1：public static boolean isEvenNumber( int number ) {\t\treturn true ; }⚫ 范例2：public static int getMax( int a, int b ) {\t\treturn 100 ;}注意：⚫ 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错调用格式：⚫ 格式1：方法名 ( 参数 ) ;⚫ 范例：isEvenNumber ( 5 ) ;⚫ 格式2：数据类型 变量名 = 方法名 ( 参数 ) ;//相当于就是拿一个变量接收一下方法的运行结果。⚫ 范例：boolean flag = isEvenNumber ( 5 ); 注意：⚫ 方法的返回值通常会使用变量接收，否则该返回值将无意义⭕注意事项：1、方法不能嵌套定义,各个方法之间是平级关系.2、 方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写return，后面不能跟具体的数据3、return语句下面，不能编写代码，因为永远执行不到，属于无效代码4、方法的参数传递，只和参数的个数，类型，顺序有关系和别的一概无关。方法重载概述⚫ 在同一个类中，定义了多个同名的方法，但每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系⚫ 简单记：同一个类中，方法名相同，参数不同的方法参数不同：个数不同、类型不同、顺序不同顺序不同可以构成重载，但是不建议！==注意：识别方法之间是否是重载关系，只看方法名和参数，跟返回值无关。==方法重载的好处⚫ 不用记忆过多繁琐的方法名字" }, { "title": "NO.04 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.4/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-04-03 12:42:43 +0000", "snippet": "每日壁纸分享NO.04 Java基础学习&amp;心得体会一、数组概念：用来存储同种数据类型的多个数据的容器。定义的格式：格式一：数据类型 [ ] 变量名 //推荐使用范例：int[ ] array;格式二：数据类型 变量名[ ]​\t 范例：int array[ ];初始化：Java中的数组必须先初始化,然后才能使用所谓初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。*1.动态初始化*格式:​\t数据类型[] 数组名 = new 数据类型[数组长度];(推荐使用)范例： int[] arr = new int[i] ; i：具体是数字解析含义：左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型左侧的中括号：代表我是一个数组左侧数组名称：给数组取一个名字右侧的new：代表创建数组的动作右侧数据类型：必须和左边的数据类型保持一致右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字*2.静态初始化*格式:省略格式:(推荐使用) 数据类型[] 数组名 = {元素值1,元素值2,元素值3,…};范例： int [ ] arr = { 1 , 2 , 3 } ;标准格式: 数据类型[] 数组名 =new 数据类型[] {元素值1,元素值2,元素值3,…};范例： int [ ] arr = new int[ ] { 1 , 2 , 3 } ;两种初始化的区别对比⚫ 动态初始化：手动指定数组长度，由系统给出默认初始化值。⚫ 静态初始化：手动指定数组元素，系统会根据元素个数，计算出数组的长度使用场景⚫ 动态初始化：只明确元素个数，不明确具体数值，推荐使用动态初始化⚫ 静态初始化：需求中已经明确了要操作的具体数据，直接静态初始化即可注意： 数组在创建完毕后，即使没有赋值也是可以取出的但取出的都是默认初始化值。数组元素的表示方式格式:​\t数组名[索引]索引值：就是一个int数字，代表数组当中元素的编号。【注意】索引值从0开始，一直到“数组的长度-1”为止。数组的内存图：Java中内存分配⚫ 栈内存：方法运行时，进入的内存，局部变量都存放于这块内存当中⚫ 堆内存：new出来的内容都会进入堆内存，并且会存在地址值⚫ 方法区：字节码文件(.class文件)加载时进入的内存⚫ 本地方法栈：调用操作系统相关资源⚫ 寄存器：交给CPU去使用数据类型 默认值整数 0浮点数 0.0布尔 false字符 空字符引用数据类型 null引用数据类型：引用、记录了地址值的变量，所对应的数据类型，就是引用数据类型例如：int[] arr = new int[3];1.java内存中的几块区域(重要的)​\t①栈​\t\t\t方法被调用的时候都会入栈​\t\t\t局部变量都被保存在栈中​\t②堆​\t\t\tnew出来的东西都在堆中​\t\t\t堆中的东西都有默认初始化值局部变量:定义在方法中的变量数组的实体保存在堆中数组名实际保存的是数组实体的地址值数组长度的表示格式:\t\t\t数组名.length数组的遍历：通过循环获取数组中的所有元素（数据）遍历：⚫ 数组遍历：将数组中所有的内容取出来，取出来之后可以（打印，求和，判断..）int[] arr={1,2,3,4,5,7};//遍历输出数组元素for(int i=0; i&lt;arr.length; i++){​\tSystem.out.println(arr[i]);}循环求数据套路：1.在循环外定义变量来存储最终要求的数据 考虑清楚变量的数据类型和初始化值2.考虑在循环过程中什么时候修改那个变量的值，怎么修改。数组操作的两个常见小问题☠⚫ 索引越界（ArrayIndexOutOfBoundsException）：访问了数组中不存在的索引对应的元素，造成索引越界问题☠⚫ 空指针异常（NullPointerException）：访问的数组已经不再指向堆内存的数据，造成空指针异常⚫ null：空值，引用数据类型的默认值，表示不指向任何有效对象" }, { "title": "NO.03 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.3/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-03-31 13:12:20 +0000", "snippet": "NO.03 Java基础学习&amp;心得体会一、分支语句1、流程控制流程控制语句分类①、顺序结构顺序结构语句顺序结构语句是Java程序，默认的执行流程，按照代码的先后顺序依次执行。从上到下，从左到右。②、分支结构(if,switch)分支结构if语句if语句格式1格式：if (关系表达式) {​\t\t\t语句体;}执行流程：① 首先计算关系表达式的值② 如果关系表达式的值为true就执行语句体③ 如果关系表达式的值为false就不执行语句体④ 继续执行后面的语句内容if语句格式2格式：if (关系表达式) {​\t\t语句体1;} else {​\t\t语句体2;}执行流程：① 首先计算关系表达式的值② 如果关系表达式的值为true就执行语句体1③ 如果关系表达式的值为false就执行语句体2④ 继续执行后面的语句内容if语句格式3格式：if (判断条件1) {​\t\t语句体1;} else if (判断条件2) {​\t\t语句体2;}…else {​\t\t语句体n+1;}执行流程：① 首先计算判断条件1的值② 如果值为true就执行语句体1；如果值为false就计算判断条件2的值③ 如果值为true就执行语句体2；如果值为false就计算判断条件3的值④ …⑤ 如果没有任何判断条件为true，就执行语句体n+1。✨switch语句switch语句格式和说明格式：switch(表达式) {\tcase 值1：\t\t\t语句体1;\t\t\tbreak;\tcase 值2：\t\t\t语句体2;\t\t\tbreak;\t…\tdefault：\t\t\t语句体n+1;\t\t\t[break;]}格式说明：⚫ 表达式：（将要匹配的值） 取值为byte、short、int、char，enum枚举，String字符串。 除了long boolean⚫ case：后面跟的是要和表达式进行比较的值 （被匹配的值）。⚫ break：表示中断，结束的意思，用来结束switch语句。⚫ default：表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。执行流程：① 首先计算表达式的值。② 依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。③ 如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后程序结束掉。注意事项：① case给出的值不允许重复② case后面的值只能是常量，不能是变量switch语句执行流程图switch语句的case穿透现象注意：在switch语句中，如果case控制的语句体后面不写break，将出现穿透现象现象：当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行直到看见break，或者将整体switch语句执行完毕，才会结束。应用场景：当发现switch语句中，多个case给出的语句体出现了重复的，就可以考虑使用case穿透来优化代码。③ 循环结构(for,while,do…while)for循环语句格式格式：for (初始化语句; 条件判断语句; 条件控制语句) {​\t\t循环体语句;}使用前提：1.有规律2.重复的执行流程：① 执行初始化语句② 执行条件判断语句，看其结果是true还是false​\t如果是false，循环结束​\t如果是true，继续执行③ 执行循环体语句④ 执行条件控制语句⑤ 回到②继续统计思想：看到”次数、数量、个数“之类的字眼，就说明需要考虑在for循环的外面定义一个int类型的count变量，初始值为0。while循环语句while循环语句格式基本格式：while (条件判断语句) {​\t\t循环体语句;}完整格式：​\t初始化语句;while (条件判断语句) {​\t循环体语句;​\t条件控制语句;}执行流程：① 执行初始化语句② 执行条件判断语句，看其结果是true还是false如果是false，循环结束如果是true，继续执行③ 执行循环体语句④ 执行条件控制语句⑤ 回到②继续do…while循环语句do…while循环语句格式基本格式：do {​\t循环体语句;}while(条件判断语句);完整格式：初始化语句;do {​\t循环体语句;​\t条件控制语句;}while(条件判断语句);执行流程：① 执行初始化语句② 执行循环体语句③ 执行条件控制语句④ 执行条件判断语句，看其结果是true还是false如果是false，循环结束如果是true，继续执行⑤ 回到②继续do…while循环语句（特点）：无论循环条件是否满足，都只是执行一次循环体。三种循环的区别：⚫ for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）⚫ do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体*（先执行后判断）*for和while的区别：⚫ 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了⚫ 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用死循环格式：for(;;) { }while(true) { }do{ }while(true);while的死循环格式是最常用的命令提示符窗口中Ctrl+C可以结束死循环跳转控制语句跳转控制语句概述跳过某次循环体内容的执行：continue注意：使用是基于条件控制的终止循环体内容的执行：break注意：使用是基于条件控制的跳转控制语句小结⚫ continue 用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行⚫ break 用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环标号：嵌套循环：定义：循环里面套循环外层循环走一次 ，内层循环走一圈外层控制行数 内层控制列数④、RandomRandom的作用和使用步骤作用：用于产生一个随机数使用步骤：① 导包import java.util.Random;导包的动作必须出现在类定义的上面② 创建对象Random r = new Random();上面这个格式里面，r 是变量名，可以变，其他的都不允许变③ 获取随机数int number = r.nextInt(10);上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变步骤：A. 导入包 import java.util.Random；B. 创建对象 Random r = new Random();C. 获取随机数 int num = r.nextInt(10);//取值范围是[0,9]​\t\t获取一个范围在1-10之间的随机数(包含10)r.nextInt(10)+1;​\t\t获取一个范围在1-100之间的随机数(包含100) \tr.nextInt(100)+1; ​\t\t获取一个范围在20-80之间的随机数(包含80)​\t\tr.nextInt(61)+20;​*小技巧:* + 号 后边加上的数值就是 取值范围的 起始值;​\t\t\t括号里的数值 用 结束值减去起始值 就是最终的数值;​\t\t\t(如果需求还要包含结束值的话,那么括号里的数值还需要+1)" }, { "title": "NO.02 Java基础学习&心得体会", "url": "/posts/JavaEEBase-NO.2/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-03-31 13:12:20 +0000", "snippet": "NO.02 Java基础学习&amp;心得体会一、运算符1、算术运算符运算符和表达式⚫ 运算符：对常量或者变量进行操作的符号⚫ 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式。符号 作用+ 加- 减* 乘/ 除% 取余注意事项：/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。注：整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。字符的“+”操作a + b 的运算中，a为int类型，b为char类型当（byte short char int）在一起运算的时候，都会提升为int之后，再进行运算⚫ ASCII码表ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是计算机中字节到字符的一套对应关系。‘a’— 97‘A’— 65‘0’— 48自增自减运算符符号 ** **作用 ** **说明++ 自增 变量的值加1-- 自减 变量的值减1⚫ ++和– 既可以放在变量的后边，也可以放在变量的前边。注意事项：⚫ 单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。⚫ 参与操作的时候​\t⚫ 如果放在变量的后边，先将该变量原本的值，取出来参与操作，随后再进行自增(++)，自减(–)。​\t\t\tint a = 10;​\t\t\tint b = a++;​\t⚫ 如果放在变量的前边，先对该变量做自增(++)或者自减(–)，然后再拿变量参与操作。​\t\t\tint a = 10;​\t\t\tint b = ++a;最常见的用法：单独使用2、赋值运算符✨符号 作用 说明= 赋值 a=10，将10赋值给变量a+= 加后赋值 a+=b，将a+b的值给a-= 减后赋值 a-=b，将a-b的值给ax= 乘后赋值 a*=b，将a×b的值给a/= 除后赋值 a/=b，将a÷b的商给a%= 取余后赋值 a%=b，将a÷b的余数给a注意事项：扩展的赋值运算符隐含了强制类型转换3、关系运算符 ( 比较运算符 ）符号 说明== a==b，判断a和b的值是否相等，成立为true，不成立为false!= a!=b，判断a和b的值是否不相等，成立为true，不成立为false&gt; a&gt;b，判断a是否大于b，成立为true，不成立为false&gt;= a&gt;=b，判断a是否大于等于b，成立为true，不成立为false&lt; a&lt;b，判断a是否小于b，成立为true，不成立为false&lt;= a&lt;=b，判断a是否小于等于b，成立为true，不成立为false注意事项：关系运算符的结果都是boolean类型，要么是true，要么是false。千万不要把“==”误写成“=”。4、逻辑运算符逻辑运算符符号 作用 说明&amp; 逻辑与 a &amp; b，a和b都是true，结果为true，否则为false 逻辑或 a b，a和b都是false，结果为false，否则为true ^ 逻辑异或 a ^ b，a和b结果不同为true，相同为false! 逻辑非 !a，结果和a的结果正好相反短路逻辑运算符符号 作用 说明&amp;&amp; 短路与 作用和&amp;相同，但是有短路效果   短路或 作用和 相同，但是有短路效果 注意事项：⚫ 逻辑与&amp;，无论左边真假，右边都要执行。​\t 短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。 ⚫ 逻辑或** **，无论左边真假，右边都要执行。 ​\t 短路或**   ，如果左边为假，右边执行；如果左边为真，右边不执行**。 最常用的逻辑运算符：**&amp;&amp;，   ，!** 3、三元运算符⚫ 格式：关系表达式 ? 表达式1 : 表达式2;⚫ 范例：a &gt; b ? a : b;计算规则：首先计算关系表达式的值如果值为true，表达式1的值就是运算结果如果值为false，表达式2的值就是运算结果" }, { "title": "正式进军Java!!!", "url": "/posts/JavaEEBase-NO.1/", "categories": "Java学习", "tags": "Java学习历程记录", "date": "2022-03-26 12:34:40 +0000", "snippet": "Java正式系统的学习，今天开始啦！！！NO.01 Java基础笔记&amp;心得体会一、注释注释概念⚫ 注释是在程序指定位置添加的说明性信息⚫ 简单理解，就是对代码的一种解释注释分类⚫ 单行注释格式：// 注释信息⚫ 多行注释格式：/* 注释信息 */⚫ 文档注释格式：/** 注释信息 */注释的注意事项⚫ 注释内容不会参与编译和运行二、关键字关键字概念⚫ 关键字：被Java赋予了特定涵义的英文单词关键字特点⚫ 关键字的字母全部小写。⚫ 常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观。三、常量常量概念⚫ 常量：在程序的执行过程中，其值不会发生改变的量（数据） 常量类型 说明 举例 字符串类型 用双括号括起来的内容 “HelloWorld” 整数常量 不带小数的数字 250，1314 小数常量 带小数的数字 13.14，52.1 字符常量 用单引号括起来的内容 ‘a’ 布尔常量 布尔值，表示真假 true，false 空常量 一个特殊的值，空值 null 四、变量⚫ 变量就是内存中的存储空间，空间中存储着经常发生改变的量（数据）⚫ 变量的定义格式数据类型 变量名 = 数据值;变量的注意事项⚫ 变量名不允许重复定义⚫ 一条语句可以定义多个变量⚫ 变量在使用之前一定要进行赋值⚫ 定义float和long变量的注意事项：F L⚫ 变量的作用域范围五、数据类型数据类型内存占用和取值范围 基本数据类型：\t\t整数：\t\t\t\tbyte\t\t1个字节\t\t\t\tshort\t\t2个字节\t\t\t\tint\t\t 4个字节\t\t\t\tlong\t\t8个字节\t\t\t\t\t小数：\t\t\t\tfloat\t\t4个字节\t\t\t\tdouble\t\t8个字节\t\t\t字符：\t\t\t\tchar\t\t2个字节\t\t\t布尔：\t\t\t\tboolean\t\t1个字节六、键盘录入键盘录入实现① 导包import java.util.Scanner;导包的动作必须出现在类定义的上边② 创建对象Scanner sc = new Scanner(System.in);上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变。③ 接收数据int i = sc.nextInt();上面这个格式里面，只有i是变量名，可以变，其他的都不允许变。七、标识符标识符概述标识符：就是给类，方法，变量等起名字的符号。标识符定义规则⚫ 由数字、字母、下划线(_)和美元符($)组成⚫ 不能以数字开头⚫ 不能是关键字⚫ 区分大小写常见命名约定：小驼峰命名法：方法、变量⚫ 约定1：标识符是一个单词的时候，首字母小写⚫ 范例1：name⚫ 约定2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写⚫ 范例2：firstName大驼峰命名法：类⚫ 约定1：标识符是一个单词的时候，首字母大写⚫ 范例1： Student⚫ 约定2：标识符由多个单词组成的时候，每个单词的首字母大写⚫ 范例2： GoodStudent八、类型转换隐式转换的过程⚫ 隐式转换把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量范例：double d = 10;简单记：小的给大的，可以直接给。隐式转换的细节⚫ 小的数据类型，和大的数据类型运算，小的会提升为大的之后，再进行运算⚫ 特殊关注：byte short char 三种数据在运算的时候，不管是否有更高的数据类型，都会提升为int，然后再进行运算强制转换的过程⚫ 强制转换把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量⚫ 格式：目标数据类型 变量名 = (目标数据类型)值或者变量;⚫ 范例：int k = (int)88.88;注意：强制类型转换，有可能会发生精度损失jdk jre jvm 关系： jdk&gt;jre&gt;jvm" } ]
